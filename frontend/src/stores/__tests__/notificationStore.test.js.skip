import { renderHook, act } from '@testing-library/react';

jest.resetModules();

// Mock safeLocalStorage
jest.mock('../../utils/storage', () => ({
  safeLocalStorage: {
    getItem: jest.fn(() => null),
    setItem: jest.fn()
  }
}));

// Mock zustand persist middleware
jest.mock('zustand/middleware', () => ({
  persist: (config) => config
}));

// Import after mocks - notificationStore has both named and default export
import useNotificationStore from '../notificationStore';

describe('NotificationStore', () => {
  beforeEach(() => {
    useNotificationStore.setState({
      notifications: [],
      unreadCount: 0,
      isOpen: false
    }, true);
    jest.clearAllMocks();
  });

  test('has correct initial state', () => {
    const { result } = renderHook(() => useNotificationStore());
    expect(result.current.notifications).toEqual([]);
    expect(result.current.unreadCount).toBe(0);
    expect(result.current.isOpen).toBe(false);
  });

  test('can add notification', () => {
    const { result } = renderHook(() => useNotificationStore());

    const notification = {
      id: 1,
      title: 'Test Notification',
      message: 'Test message',
      type: 'info',
      read: false,
      createdAt: new Date().toISOString()
    };

    act(() => {
      useNotificationStore.setState({
        notifications: [notification],
        unreadCount: 1
      });
    });

    expect(result.current.notifications).toHaveLength(1);
    expect(result.current.unreadCount).toBe(1);
  });

  test('can mark notification as read', () => {
    const { result } = renderHook(() => useNotificationStore());

    act(() => {
      useNotificationStore.setState({
        notifications: [
          { id: 1, title: 'Test', read: false }
        ],
        unreadCount: 1
      });
    });

    act(() => {
      const updatedNotifications = result.current.notifications.map(n =>
        n.id === 1 ? { ...n, read: true } : n
      );
      useNotificationStore.setState({
        notifications: updatedNotifications,
        unreadCount: 0
      });
    });

    expect(result.current.notifications[0].read).toBe(true);
    expect(result.current.unreadCount).toBe(0);
  });

  test('can toggle notification panel', () => {
    const { result } = renderHook(() => useNotificationStore());

    act(() => {
      useNotificationStore.setState({ isOpen: true });
    });

    expect(result.current.isOpen).toBe(true);

    act(() => {
      useNotificationStore.setState({ isOpen: false });
    });

    expect(result.current.isOpen).toBe(false);
  });

  test('handles multiple notifications', () => {
    const { result } = renderHook(() => useNotificationStore());

    const notifications = [
      { id: 1, title: 'Notification 1', read: false },
      { id: 2, title: 'Notification 2', read: false },
      { id: 3, title: 'Notification 3', read: true }
    ];

    act(() => {
      useNotificationStore.setState({
        notifications,
        unreadCount: 2
      });
    });

    expect(result.current.notifications).toHaveLength(3);
    expect(result.current.unreadCount).toBe(2);
  });

  test('can clear all notifications', () => {
    const { result } = renderHook(() => useNotificationStore());

    act(() => {
      useNotificationStore.setState({
        notifications: [
          { id: 1, title: 'Test' },
          { id: 2, title: 'Test 2' }
        ],
        unreadCount: 2
      });
    });

    act(() => {
      useNotificationStore.setState({
        notifications: [],
        unreadCount: 0
      });
    });

    expect(result.current.notifications).toEqual([]);
    expect(result.current.unreadCount).toBe(0);
  });
});
